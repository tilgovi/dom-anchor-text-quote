{"version":3,"sources":["TextQuoteAnchor.js"],"names":["global","factory","define","amd","exports","module","require","mod","DiffMatchPatch","TextPositionAnchor","TextQuoteAnchor","this","_diffMatchPatch","_domAnchorTextPosition","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_DiffMatchPatch","_TextPositionAnchor","SLICE_LENGTH","SLICE_RE","RegExp","String","CONTEXT_LENGTH","root","exact","context","arguments","undefined","Error","prefix","suffix","value","options","toPositionAnchor","toRange","selector","type","hint","dmp","Match_Distance","textContent","slices","match","loc","start","Number","POSITIVE_INFINITY","end","NEGATIVE_INFINITY","result","havePrefix","haveSuffix","contextMissing","match_main","Match_Threshold","firstSlice","shift","foldSlices","acc","slice","Math","min","max","reduce","range","position","fromRange","fromPositionAnchor","anchor","substr","prefixStart","suffixEnd"],"mappings":"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","file":"TextQuoteAnchor.min.js","sourcesContent":["import DiffMatchPatch from 'diff-match-patch';\nimport TextPositionAnchor from 'dom-anchor-text-position';\n\n// The DiffMatchPatch bitap has a hard 32-character pattern length limit.\nconst SLICE_LENGTH = 32;\nconst SLICE_RE = new RegExp('(.|[\\r\\n]){1,' + String(SLICE_LENGTH) + '}', 'g');\nconst CONTEXT_LENGTH = SLICE_LENGTH;\n\n\nexport default class TextQuoteAnchor {\n  constructor(root, exact, context = {}) {\n    if (root === undefined) {\n      throw new Error('missing required parameter \"root\"');\n    }\n    if (exact === undefined) {\n      throw new Error('missing required parameter \"exact\"');\n    }\n    this.root = root;\n    this.exact = exact;\n    this.prefix = context.prefix;\n    this.suffix = context.suffix;\n  }\n\n  static fromRange(root, range) {\n    if (range === undefined) {\n      throw new Error('missing required parameter \"range\"');\n    }\n\n    let position = TextPositionAnchor.fromRange(root, range);\n    return this.fromPositionAnchor(position);\n  }\n\n  static fromSelector(root, selector = {}) {\n    return new TextQuoteAnchor(root, selector.exact, selector);\n  }\n\n  static fromPositionAnchor(anchor) {\n    let root = anchor.root;\n\n    let {start, end} = anchor;\n    let exact = root.textContent.substr(start, end - start);\n\n    let prefixStart = Math.max(0, start - CONTEXT_LENGTH);\n    let prefix = root.textContent.substr(prefixStart, start - prefixStart);\n\n    let suffixEnd = Math.min(root.textContent.length, end + CONTEXT_LENGTH);\n    let suffix = root.textContent.substr(end, suffixEnd - end);\n\n    return new TextQuoteAnchor(root, exact, {prefix, suffix});\n  }\n\n  toRange(options) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  toSelector() {\n    let selector = {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n    };\n    if (this.prefix !== undefined) selector.prefix = this.prefix;\n    if (this.suffix !== undefined) selector.suffix = this.suffix;\n    return selector;\n  }\n\n  toPositionAnchor(options = {}) {\n    let {hint} = options;\n    let root = this.root;\n    let dmp = new DiffMatchPatch();\n\n    dmp.Match_Distance = root.textContent.length * 2;\n\n    // Work around a hard limit of the DiffMatchPatch bitap implementation.\n    // The search pattern must be no more than SLICE_LENGTH characters.\n    let slices = this.exact.match(SLICE_RE);\n    let loc = (hint === undefined) ? ((root.textContent.length / 2) | 0) : hint;\n    let start = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    let result = -1;\n    let havePrefix = this.prefix !== undefined;\n    let haveSuffix = this.suffix !== undefined;\n    let contextMissing = false;\n\n    // If the prefix is known then search for that first.\n    if (havePrefix) {\n      result = dmp.match_main(root.textContent, this.prefix, loc);\n      if (result > -1) {\n        loc = result + this.prefix.length;\n      } else {\n        contextMissing = true;\n      }\n    }\n\n    // If we have a suffix, and either a) we have no prefix, or b) the prefix\n    // wasn't found, then search for it.\n    if (haveSuffix && (!havePrefix || contextMissing)) {\n      result = dmp.match_main(root.textContent, this.suffix, loc);\n      if (result > -1) {\n        loc = result - this.suffix.length - this.exact.length;\n        contextMissing = false;\n      } else {\n        contextMissing = true;\n      }\n    }\n\n    // If we had a prefix or suffix, but didn't find them, we should now be\n    // pretty skeptical that the exact string is in the document.\n    //\n    // For strings that are likely to appear in the document simply by chance\n    // (i.e. short ones), we should make the match requirements stricter in this\n    // case. A match threshold of 0.25 corresponds (very roughly) to a word\n    // deletion/insertion in a string of length 32 (average English word length\n    // of 8) and permits no errors for strings of length < 4.\n    if (contextMissing && this.exact.length < SLICE_LENGTH) {\n      dmp.Match_Threshold = 0.25;\n    }\n\n    // Search for the first slice.\n    let firstSlice = slices.shift();\n    result = dmp.match_main(root.textContent, firstSlice, loc);\n    if (result > -1) {\n      start = result;\n      loc = end = start + firstSlice.length;\n    } else {\n      throw new Error('no match found');\n    }\n\n    // Create a fold function that will reduce slices to positional extents.\n    let foldSlices = (acc, slice) => {\n      let result = dmp.match_main(root.textContent, slice, acc.loc);\n      if (result === -1) {\n        throw new Error('no match found');\n      }\n\n      // The next slice should follow this one closely.\n      acc.loc = result + slice.length;\n\n      // Expand the start and end to a quote that includes all the slices.\n      acc.start = Math.min(acc.start, result);\n      acc.end = Math.max(acc.end, result + slice.length);\n\n      return acc;\n    };\n\n    // Use the fold function to establish the full quote extents.\n    // Expect the slices to be close to one another.\n    // This distance is deliberately generous for now.\n    dmp.Match_Distance = 64;\n    let acc = slices.reduce(foldSlices, {\n      start: start,\n      end: end,\n      loc: loc,\n    });\n\n    return new TextPositionAnchor(root, acc.start, acc.end);\n  }\n}\n"],"sourceRoot":"./"}